"use strict";(self.webpackChunkreference=self.webpackChunkreference||[]).push([[2359],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return c}});var i=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,i,n=function(e,t){if(null==e)return{};var a,i,n={},r=Object.keys(e);for(i=0;i<r.length;i++)a=r[i],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)a=r[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=i.createContext({}),h=function(e){var t=i.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},m=function(e){var t=h(e.components);return i.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=h(a),c=n,d=u["".concat(l,".").concat(c)]||u[c]||p[c]||r;return a?i.createElement(d,s(s({ref:t},m),{},{components:a})):i.createElement(d,s({ref:t},m))}));function c(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,s=new Array(r);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:n,s[1]=o;for(var h=2;h<r;h++)s[h]=a[h];return i.createElement.apply(null,s)}return i.createElement.apply(null,a)}u.displayName="MDXCreateElement"},8037:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return h},toc:function(){return m},default:function(){return u}});var i=a(7462),n=a(3366),r=(a(7294),a(3905)),s=["components"],o={sidebar_position:2},l=void 0,h={unversionedId:"Notes Sep 2021/30 Important DS and Algo",id:"Notes Sep 2021/30 Important DS and Algo",isDocsHomePage:!1,title:"30 Important DS and Algo",description:"Complete Introduction to the 30 Most Essential Data Structures & Algorithms",source:"@site/docs/Notes Sep 2021/30 Important DS and Algo.md",sourceDirName:"Notes Sep 2021",slug:"/Notes Sep 2021/30 Important DS and Algo",permalink:"/reference/docs/Notes Sep 2021/30 Important DS and Algo",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/Notes Sep 2021/30 Important DS and Algo.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Tutorial Intro",permalink:"/reference/docs/intro"},next:{title:"CSS Modules with React",permalink:"/reference/docs/Notes Sep 2021/CSS Modules with React"}},m=[{value:"Complete Introduction to the 30 Most Essential Data Structures &amp; Algorithms",id:"complete-introduction-to-the-30-most-essential-data-structures--algorithms",children:[]},{value:"Contents",id:"contents",children:[{value:"I. Data Structures",id:"i-data-structures",children:[]},{value:"II. Algorithms",id:"ii-algorithms",children:[]}]},{value:"I. Data Structures",id:"i-data-structures-1",children:[{value:"1. Arrays",id:"1-arrays",children:[]},{value:"2. Linked Lists",id:"2-linked-lists",children:[]},{value:"3. Stacks",id:"3-stacks",children:[]},{value:"4. Queues",id:"4-queues",children:[]},{value:"5. Maps &amp; Hash Tables",id:"5-maps--hash-tables",children:[]},{value:"6. Graphs",id:"6-graphs",children:[]},{value:"7. Trees",id:"7-trees",children:[]},{value:"8. Binary Trees &amp; Binary Search Trees",id:"8-binary-trees--binary-search-trees",children:[]},{value:"9. Self-balancing trees",id:"9-self-balancing-trees",children:[]},{value:"10.Heaps",id:"10heaps",children:[]},{value:"11.Tries",id:"11tries",children:[]},{value:"12. Segment Trees",id:"12-segment-trees",children:[]},{value:"13. Fenwick Trees",id:"13-fenwick-trees",children:[]},{value:"14. Disjoint Set Union",id:"14-disjoint-set-union",children:[]},{value:"15. Minimum Spanning Trees",id:"15-minimum-spanning-trees",children:[]}]},{value:"II. Algorithms",id:"ii-algorithms-1",children:[{value:"1. Divide and Conquer",id:"1-divide-and-conquer",children:[]},{value:"2. Sorting Algorithms",id:"2-sorting-algorithms",children:[]},{value:"3. Searching Algorithms",id:"3-searching-algorithms",children:[]},{value:"4. Sieve of Eratosthenes",id:"4-sieve-of-eratosthenes",children:[]},{value:"5. Knuth-Morris-Pratt Algorithm",id:"5-knuth-morris-pratt-algorithm",children:[]},{value:"6. Greedy",id:"6-greedy",children:[]},{value:"7. Dynamic Programming",id:"7-dynamic-programming",children:[]},{value:"8. Longest Common Subsequence",id:"8-longest-common-subsequence",children:[]},{value:"9. Longest Increasing Subsequence",id:"9-longest-increasing-subsequence",children:[]},{value:"10. Convex Hull",id:"10-convex-hull",children:[]},{value:"11. Graph Traversals",id:"11-graph-traversals",children:[]},{value:"12. Floyd-Warshall Algorithm",id:"12-floyd-warshall-algorithm",children:[]},{value:"13. Dijkstra\u2019s Algorithm &amp; Bellman-Ford Algorithm",id:"13-dijkstras-algorithm--bellman-ford-algorithm",children:[]},{value:"14. Kruskal\u2019s Algorithm",id:"14-kruskals-algorithm",children:[]},{value:"15. Topological Sorting",id:"15-topological-sorting",children:[]}]}],p={toc:m};function u(e){var t=e.components,a=(0,n.Z)(e,s);return(0,r.kt)("wrapper",(0,i.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"complete-introduction-to-the-30-most-essential-data-structures--algorithms"},"Complete Introduction to the 30 Most Essential Data Structures & Algorithms"),(0,r.kt)("p",null,"Data Structures & Algorithms (DSA) is often considered to be an intimidating topic\u200a-\u200aa common misbelief. Forming the foundation of the most innovative concepts in tech, they are essential in both jobs/internships applicants' and experienced programmers' journey. Mastering DSA implies that you are able to use your computational and algorithmic thinking in order to solve never-before-seen problems and contribute to any tech company's value (including your own!). By understanding them, you can improve the maintainability, extensibility and efficiency of your code."),(0,r.kt)("p",null,"These being said, I've decided to centralize all the DSA threads that I have been posting on ",(0,r.kt)("a",{parentName:"p",href:"https://twitter.com/gg_iulia"},"Twitter")," during my ",(0,r.kt)("a",{parentName:"p",href:"https://twitter.com/gg_iulia/status/1283813774437359618"},"#100DaysOfCode")," challenge. This article is aiming to make DSA not look as intimidating as it is believed to be. It includes the 15 most useful data structures and the 15 most important algorithms that can help you ace your interviews and improve your competitive programming skills. Each chapter includes useful links with additional information and practice problems. DS topics are accompanied by a graphic representation and key information. Every algorithm is implemented into a continuously updating ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/iuliagroza"},"Github")," ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/iuliagroza/Algorithms"},"repo"),". At the time of writing, it contains the pseudocode, C++, Python and Java (still in progress) implementations of each mentioned algorithm (and not only). This ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/iuliagroza/Algorithms"},"repository")," is expanding thanks to other talented and passionate developers that are contributing to it by adding new algorithms and new programming languages implementations."),(0,r.kt)("h2",{id:"contents"},"Contents"),(0,r.kt)("h3",{id:"i-data-structures"},"I. Data Structures"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Arrays"),(0,r.kt)("li",{parentName:"ol"},"Linked Lists"),(0,r.kt)("li",{parentName:"ol"},"Stacks"),(0,r.kt)("li",{parentName:"ol"},"Queues"),(0,r.kt)("li",{parentName:"ol"},"Maps & Hash Tables"),(0,r.kt)("li",{parentName:"ol"},"Graphs"),(0,r.kt)("li",{parentName:"ol"},"Trees"),(0,r.kt)("li",{parentName:"ol"},"Binary Trees & Binary Search Trees"),(0,r.kt)("li",{parentName:"ol"},"Self-balancing Trees (AVL Trees, Red-Black Trees, Splay Trees)"),(0,r.kt)("li",{parentName:"ol"},"Heaps"),(0,r.kt)("li",{parentName:"ol"},"Tries"),(0,r.kt)("li",{parentName:"ol"},"Segment Trees"),(0,r.kt)("li",{parentName:"ol"},"Fenwick Trees"),(0,r.kt)("li",{parentName:"ol"},"Disjoint Set Union"),(0,r.kt)("li",{parentName:"ol"},"Minimum Spanning Trees")),(0,r.kt)("h3",{id:"ii-algorithms"},"II. Algorithms"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Divide and Conquer"),(0,r.kt)("li",{parentName:"ol"},"Sorting Algorithms (Bubble Sort, Counting Sort, Quick Sort, Merge Sort, Radix Sort)"),(0,r.kt)("li",{parentName:"ol"},"Searching Algorithms (Linear Search, Binary Search)"),(0,r.kt)("li",{parentName:"ol"},"Sieve of Eratosthenes"),(0,r.kt)("li",{parentName:"ol"},"Knuth-Morris-Pratt Algorithm"),(0,r.kt)("li",{parentName:"ol"},"Greedy I (Maximum number of non-overlapping intervals on an axis)"),(0,r.kt)("li",{parentName:"ol"},"Greedy II (Fractional Knapsack Problem)"),(0,r.kt)("li",{parentName:"ol"},"Dynamic Programming I (0\u20131 Knapsack Problem)"),(0,r.kt)("li",{parentName:"ol"},"Dynamic Programming II (Longest Common Subsequence)"),(0,r.kt)("li",{parentName:"ol"},"Dynamic Programming III (Longest Increasing Subsequence)"),(0,r.kt)("li",{parentName:"ol"},"Convex Hull"),(0,r.kt)("li",{parentName:"ol"},"Graph Traversals (Breadth-First Search, Depth-First Search)"),(0,r.kt)("li",{parentName:"ol"},"Floyd-Warshall / Roy-Floyd Algorithm"),(0,r.kt)("li",{parentName:"ol"},"Dijkstra's Algorithm & Bellman-Ford Algorithm"),(0,r.kt)("li",{parentName:"ol"},"Topological Sorting")),(0,r.kt)("h2",{id:"i-data-structures-1"},"I. Data Structures"),(0,r.kt)("h3",{id:"1-arrays"},"1. Arrays"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--VSQ0ht-I--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/yu4y9j1x49hjbig2yr0i.png"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--VSQ0ht-I--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/yu4y9j1x49hjbig2yr0i.png",alt:"Arrays"}))),(0,r.kt)("p",null,"Arrays are the simplest and most common data structures. They are characterised by the facile access of elements by index (position)."),(0,r.kt)("h4",{id:"what-are-they-used-for"},"What are they used for?"),(0,r.kt)("p",null,"Imagine having a theater chair row. Each chair has assigned a position (from left to right), therefore every spectator will have assigned the number from the chair (s)he will be sitting on. This is an array. Expand the problem to the whole theater (rows and columns of chairs) and you will have a 2D array (matrix)!"),(0,r.kt)("h4",{id:"properties"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"elements' values are placed in order and accessed by their index from 0 to the length of the array-1;"),(0,r.kt)("li",{parentName:"ul"},"an array is a continuous block of memory;"),(0,r.kt)("li",{parentName:"ul"},"they are usually made of elements of the same type (it depends on the programming language);"),(0,r.kt)("li",{parentName:"ul"},"access and addition of elements are fast; search and deletion are not done in O(1).")),(0,r.kt)("h4",{id:"useful-links"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.geeksforgeeks.org/introduction-to-arrays/"},"GeeksforGeeks: Introduction to arrays")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://leetcode.com/tag/array/"},"LeetCode Problem Set")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://algorithms.tutorialhorizon.com/top-40-problems-on-arrays/"},"Top 40 problems on arrays"))),(0,r.kt)("h3",{id:"2-linked-lists"},"2. Linked Lists"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--vCRkNVeb--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/i9hgxk42a1u1sawiexzi.jpg"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--vCRkNVeb--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/i9hgxk42a1u1sawiexzi.jpg",alt:"Linked Lists 1"}))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--WR5Y_jcl--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/0bo1zergiy0wm6i0fszq.jpg"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--WR5Y_jcl--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/0bo1zergiy0wm6i0fszq.jpg",alt:"Linked Lists 2"}))),(0,r.kt)("p",null,"Linked lists are linear data structures, just like arrays. The main difference between linked lists and arrays is that elements of a linked list are not stored at contiguous memory locations. It is composed of nodes\u200a-\u200aentities that store the current element's value and an address reference to the next element. That way, elements are linked by pointers."),(0,r.kt)("h4",{id:"what-are-they-used-for-1"},"What are they used for?"),(0,r.kt)("p",null," One relevant application of linked lists is the implementation of the previous and the next page of a browser. A double linked list is the perfect data structure to store the pages displayed by a user's search."),(0,r.kt)("h4",{id:"properties-1"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"they come in three types: singly, doubly and circular;"),(0,r.kt)("li",{parentName:"ul"},"elements are NOT stored in a contiguous block of memory;"),(0,r.kt)("li",{parentName:"ul"},"perfect for an excellent memory management (using pointers implies dynamic memory usage);"),(0,r.kt)("li",{parentName:"ul"},"insertion and deletion are fast; accessing and searching elements are done in linear time.")),(0,r.kt)("h4",{id:"useful-links-1"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://visualgo.net/en/list"},"Visualizing Linked Lists")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.interviewbit.com/courses/programming/topics/linked-lists/"},"InterviewBit: Linked Lists"))),(0,r.kt)("h3",{id:"3-stacks"},"3. Stacks"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--vtKSJYB7--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/bgrata16vs1l4th5f4vl.png"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--vtKSJYB7--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/bgrata16vs1l4th5f4vl.png",alt:"Stacks"}))),(0,r.kt)("p",null,"A stack is an abstract data type that formalizes the concept of restricted access collection. The restriction follows the rule LIFO (Last In, First Out). Therefore, the last element added in the stack is the first element you remove from it.\nStacks can be implemented using arrays or linked lists."),(0,r.kt)("h4",{id:"what-are-they-used-for-2"},"What are they used for?"),(0,r.kt)("p",null,"The most common real-life example uses plates placed one over another in the canteen. The plate which is at the top is the first to be removed. The plate placed at the bottommost is the one that remains in the stack for the longest period of time.\nOne situation when stacks are the most useful is when you need to obtain the reverse order of given elements. Just push them all in a stack and then pop them.\nAnother interesting application is the Valid Parentheses Problem. Given a string of parantheses, you can check that they are matched using a stack."),(0,r.kt)("h4",{id:"properties-2"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"you can only access the last element at one time (the one at the top);"),(0,r.kt)("li",{parentName:"ul"},"one disadvantage is that once you pop elements from the top in order to access other elements, their values will be lost from the stack's memory;"),(0,r.kt)("li",{parentName:"ul"},"access of other elements is done in linear time; any other operation is in O(1).")),(0,r.kt)("h4",{id:"useful-links-2"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://csacademy.com/lesson/stack_introduction"},"CS Academy: Stack Introduction")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://csacademy.com/lesson/stack_application_soldiers_row/"},"CS Academy: Stack Application\u200a-\u200aSoldiers Row")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://leetcode.com/tag/stack/"},"LeetCode Problem Set"))),(0,r.kt)("h3",{id:"4-queues"},"4. Queues"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--fH8NG9ln--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/u2lwvsrbxo3v17do75cz.png"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--fH8NG9ln--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/u2lwvsrbxo3v17do75cz.png",alt:"Queues 1"}))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--41mhnVJo--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/04yz79wxr2waafenx0vz.jpg"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--41mhnVJo--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/04yz79wxr2waafenx0vz.jpg",alt:"Queues 2"}))),(0,r.kt)("p",null,"A queue is another data type from the restricted access collection, just like the previously discussed stack. The main difference is that the queue is organised after the FIFO (First In, First Out) model: the first inserted element in the queue is the first element to be removed. Queues can be implemented using a fixed length array, a circular array or a linked list."),(0,r.kt)("h4",{id:"what-are-they-used-for-3"},"What are they used for?"),(0,r.kt)("p",null," The best use of this abstract data type (ADT) is, of course, the simulation of a real life queue. For example, in a call center application, a queue is used for saving the clients that are waiting to receive help from the consultant\u200a-\u200athese clients should get help in the order they called.\nOne special and very important type of queue is the priority queue. The elements are introduced in the queue based on a \"priority\" associated with them: the element with the highest priority is the first introduced in the queue. This ADT is essential in many Graph Algorithms (Dijkstra's Algorithm, BFS, Prim's Algorithm, Huffman Coding\u200a-\u200amore about them below). It is implemented using a heap.\nAnother special type of queue is the deque (",(0,r.kt)("em",{parentName:"p"},"pun alert"),' it\'s pronounced "deck"). Elements can be inserted/removed from both endings of the queue.'),(0,r.kt)("h4",{id:"properties-3"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'we can directly access only the "oldest" element introduced;'),(0,r.kt)("li",{parentName:"ul"},"searching elements will remove all the accessed elements from the queue's memory;"),(0,r.kt)("li",{parentName:"ul"},"popping/pushing elements or getting the front of the queue is done in constant time. Searching is linear.")),(0,r.kt)("h4",{id:"useful-links-3"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://cs.usfca.edu/~galles/visualization/QueueArray.html"},"Visualizing Queues")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://leetcode.com/tag/queue/"},"LeetCode Problem Set"))),(0,r.kt)("h3",{id:"5-maps--hash-tables"},"5. Maps & Hash Tables"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--mNgGZaWG--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/ccvda1iqwh3rvldlyx3n.png"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--mNgGZaWG--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/ccvda1iqwh3rvldlyx3n.png",alt:"Maps"}))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--P-CJxZTj--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/24dtou0fx9xaal0bnk9g.jpg"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--P-CJxZTj--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/24dtou0fx9xaal0bnk9g.jpg",alt:"Hash Tables"}))),(0,r.kt)("p",null,"Maps (dictionaries) are abstract data types that contain a collection of keys and a collection of values. Each key has a value associated with it.\nA hash table is a particular type of map. It uses a hash function to generate a hash code, into an array of buckets or slots: the key is hashed and the resulting hash indicates where the value is stored.\nThe most common hash function (among many) is the modulo constant function. e. g. if the constant is 6, the value of the key x is ",(0,r.kt)("em",{parentName:"p"},"x%6"),".\nIdeally, a hash function will assign each key to a unique bucket, but most of their designs employ an imperfect function, which might conduct to collision between keys with the same generated value. Such collisions are always accomodated in some way."),(0,r.kt)("h4",{id:"what-are-they-used-for-4"},"What are they used for?"),(0,r.kt)("p",null," The most known application of maps is a language dictionary. Each word from a language has assigned its definition to it. It is implemented using an ordered map (its keys are alphabetically ordered).\nContacts is also a map. Each name has a phone number assigned to it.\nAnother useful application is normalization of values. Let's say we want to assign to each minute of a day (24 hours = 1440 minutes) an index from 0 to 1439. The hash function will be ",(0,r.kt)("em",{parentName:"p"},"h(x) = x.hour","*","60+x.minute"),"."),(0,r.kt)("h4",{id:"properties-4"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"keys are unique (no duplicates);"),(0,r.kt)("li",{parentName:"ul"},"collision resistance: it should be hard to find two different inputs with the same key;"),(0,r.kt)("li",{parentName:"ul"},"pre-image resistance: given a value H, it should be hard to find a key x, such that ",(0,r.kt)("em",{parentName:"li"},"h(x)=H"),";"),(0,r.kt)("li",{parentName:"ul"},"second pre-image resistance: given a key and its value, it should be hard to find another key with the same value;"),(0,r.kt)("li",{parentName:"ul"},"terminology:"),(0,r.kt)("li",{parentName:"ul"},"*",' "map": Java, C++;'),(0,r.kt)("li",{parentName:"ul"},"*",' "dictionary": Python, JavaScript, .NET;'),(0,r.kt)("li",{parentName:"ul"},"*",' "associative array": PHP.'),(0,r.kt)("li",{parentName:"ul"},"because maps are implemented using self-balancing red-black trees (explained below), all operations are done in O(log n); all hash table operations are constant.")),(0,r.kt)("h4",{id:"useful-links-4"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://codeforces.com/problemset?tags=hashing"},"Codeforces Problem Set"))),(0,r.kt)("h3",{id:"6-graphs"},"6. Graphs"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--3v71jFRA--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/2rfe0k34shg45eliat18.jpg"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--3v71jFRA--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/2rfe0k34shg45eliat18.jpg",alt:"Graphs"}))),(0,r.kt)("p",null,"A graph is a non-linear data structure representing a pair of two sets: ",(0,r.kt)("em",{parentName:"p"},"G={V, E}"),", where V is the set of vertices (nodes), and E the set of edges (arrows). Nodes are values interconnected by edges\u200a-\u200alines that depict the dependency (sometimes associated with a cost/distance) between two nodes.\nThere are two main types of graphs: directed and undirected. In an undirected graph, the edge ",(0,r.kt)("em",{parentName:"p"},"(x, y)")," is available in both directions: ",(0,r.kt)("em",{parentName:"p"},"(x, y)")," and ",(0,r.kt)("em",{parentName:"p"},"(y, x)"),". In a directed graph, the edge ",(0,r.kt)("em",{parentName:"p"},"(x, y)")," is called an arrow and the direction is given by the order of the vertices in its name: arrow ",(0,r.kt)("em",{parentName:"p"},"(x, y)")," is different from arrow ",(0,r.kt)("em",{parentName:"p"},"(y, x)"),"."),(0,r.kt)("h4",{id:"what-are-they-used-for-5"},"What are they used for?"),(0,r.kt)("p",null," Graphs are the foundation of every type of network: a social network (like Facebook, LinkedIn), or even the network of streets from a city. Every user of a social media platform is a structure containing all of his/her personal data\u200a-\u200ait represents a node of the network. Friendships on Facebook are edges in an undirected graph (because it is reciprocal), while on Instagram or Twitter, the relationship between an account and its followers/following accounts are arrows in a directed graph (not reciprocal)."),(0,r.kt)("h4",{id:"properties-5"},"Properties"),(0,r.kt)("p",null," Graph theory is a vast domain, but we are going to highlight a few of the most known concepts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the degree of a node in an undirected graph is the number of its incident edges;"),(0,r.kt)("li",{parentName:"ul"},"the internal/external degree of a node in a directed graph is the number of arrows that direct to/from that node;"),(0,r.kt)("li",{parentName:"ul"},"a chain from node x to node y is a succesion of adjacent edges, with x as its left extremity and y as its right;"),(0,r.kt)("li",{parentName:"ul"},"a cycle is a chain were x=y; a graph can be cyclic/acyclic; a graph is connected if there is a chain between any two nodes from V;"),(0,r.kt)("li",{parentName:"ul"},"a graph can be traversed and processed using Breadth First Search (BFS) or Depth First Search (DFS), both done in O(|V|+|E|), where |S| is the cardinal of the set S; Check the links below for other essential info in graph theory.")),(0,r.kt)("h4",{id:"useful-links-5"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://csacademy.com/app/graph_editor/"},"Graph Editor")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)"},"Wikipedia: Graphs\u200a-\u200aDiscrete Mathematics")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://csacademy.com/lesson/graph_representation"},"CS Academy: Graph representation")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://leetcode.com/tag/graph/"},"LeetCode Problem Set"))),(0,r.kt)("h3",{id:"7-trees"},"7. Trees"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--IWrGT3rJ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/fabyf9kv5c6jphvke5g2.jpg"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--IWrGT3rJ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/fabyf9kv5c6jphvke5g2.jpg",alt:"Trees"}))),(0,r.kt)("p",null,"A tree is an undirected graph, minimal in terms of connectivity (if we eliminate a single edge the graph won't be connected anymore) and maximal in terms of acyclicity (if we add a single edge the graph won't be acyclic anymore). So any acyclic connected undirected graph is a tree, but for simplicity, we will refer to rooted trees as trees.\nA root is one fixed node that establishes the direction of the edges in the tree, so that's where everything \"starts\". Leaves are the terminal nodes of the tree\u200a-\u200athat's where everything \"ends\".\nA child of a vertice is its incident vertice below it. A vertice can have multiple children. A vertice's parent is its incident vertice above it\u200a-\u200ait's unique."),(0,r.kt)("h4",{id:"what-are-they-used-for-6"},"What are they used for?"),(0,r.kt)("p",null," We use trees anytime we should depict a hierarchy. Our own genealogical tree is the perfect example. Your oldest ancestor is the root of the tree. The youngest generation represents the leaves' set.\nTrees can also represent the subordinate relationship in the company you work for. That way you can find out who is your manager and who you should manage."),(0,r.kt)("h4",{id:"properties-6"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the root has no parent;"),(0,r.kt)("li",{parentName:"ul"},"leaves have no children;"),(0,r.kt)("li",{parentName:"ul"},"the length of the chain between the root and a node x represents the level x is situated on;"),(0,r.kt)("li",{parentName:"ul"},"the height of a tree is the maximum level of it (3 in our example);"),(0,r.kt)("li",{parentName:"ul"},"the most common method to traverse a tree is DFS in O(|V|+|E|), but we can use BFS too; the order of the nodes traversed in any graph using DFS form the DFS tree that indicates us the time a node has been visited.")),(0,r.kt)("h4",{id:"useful-links-6"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://tutorialspoint.com/data_structures_algorithms/tree_data_structure.htm"},"TutorialsPoint: Trees")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://codeforces.com/problemset?tags=trees"},"Codeforces Problem Set"))),(0,r.kt)("h3",{id:"8-binary-trees--binary-search-trees"},"8. Binary Trees & Binary Search Trees"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--6E3LamaU--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/218ybm8tap68my4pmw7h.jpg"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--6E3LamaU--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/218ybm8tap68my4pmw7h.jpg",alt:"BT"}))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--L00Lpm7U--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/tq416uj7entas1sqyiua.png"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--L00Lpm7U--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/tq416uj7entas1sqyiua.png",alt:"BST"}))),(0,r.kt)("p",null,"A Binary Tree is a special type of tree: each vertice can have maximum two children. In a strict binary tree, every node has exactly two children, except for the leaves. A complete binary tree with n levels has all ",(0,r.kt)("em",{parentName:"p"},"2\u207f-1")," possible nodes.\nA binary search tree is a binary tree where nodes' values belong to a totally ordered set\u200a-\u200aany arbitrary chosen node's value is bigger than all the values from the left subtree and smaller than the ones from the right subtree."),(0,r.kt)("h4",{id:"what-are-they-used-for-7"},"What are they used for?"),(0,r.kt)("p",null," One important application of BTs is the representation and evaluation of logical expressions. Each expression can be decomposed into variables/constants and operators. This method of expression writing is called Reverse Polish Notation (RPN). That way, they can form a binary tree, where internal nodes are operators and leaves are variables/constants\u200a-\u200ait's called an Abstract Syntax Tree (AST).\nBSTs are frequently used because of their fast search of keys property. AVL Trees, Red-Black Trees, ordered sets and maps are implemented using BSTs."),(0,r.kt)("h4",{id:"properties-7"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"there are three types of DFS traversals for BTs:"),(0,r.kt)("li",{parentName:"ul"},"*"," Preorder (Root, Left, Right);"),(0,r.kt)("li",{parentName:"ul"},"*"," Inorder (Left, Root, Right);"),(0,r.kt)("li",{parentName:"ul"},"*"," Postorder (Left, Right, Root); all done in O(n) time;"),(0,r.kt)("li",{parentName:"ul"},"the inorder traversal gives us all the nodes in the tree in ascending order;"),(0,r.kt)("li",{parentName:"ul"},"the left-most node is the minimum value in the BST and the rightmost is the maximum;"),(0,r.kt)("li",{parentName:"ul"},"notice that RPN is the inorder traversal of the AST;"),(0,r.kt)("li",{parentName:"ul"},"a BST has the advantages of a sorted array, but the disadvantage of logarithmic insertion\u200a-\u200aall of its operations are done in O(log n) time.")),(0,r.kt)("h4",{id:"useful-links-7"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.geeksforgeeks.org/binary-tree-data-structure/"},"GeeksforGeeks: Binary Trees")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://geeksforgeeks.org/evaluation-of-expression-tree/amp/?ref=rp"},"GeeksforGeeks: Evaluation of Expression Trees")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://medium.com/techie-delight/binary-search-tree-bst-practice-problems-and-interview-questions-ea13a6731098"},"Medium: Best BST practice problems and interview questions"))),(0,r.kt)("h3",{id:"9-self-balancing-trees"},"9. Self-balancing trees"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--ILuL1NxC--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/l6kg17pcg4m3gwwm649v.jpg"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--ILuL1NxC--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/l6kg17pcg4m3gwwm649v.jpg",alt:"AVL"}))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--3KyhW9wk--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/f4w005asky5ampwwjgbg.jpg"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--3KyhW9wk--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/f4w005asky5ampwwjgbg.jpg",alt:"Red-Black"}))),(0,r.kt)("p",null,"All these types of trees are self-balancing binary search trees. The difference is in the way they balance their height in logarithmic time.\nAVL Trees are self-balancing after every insertion/deletion because the difference in module between the heights of the left subtree and the right subtree of a node is maximum 1. AVLs are named after their inventors: Adelson-Velsky and Landis.\nIn Red-Black Trees, each node stores an extra bit representing color, used to ensure the balance after every insert/delete operation.\nIn Splay trees, recently accessed nodes can be quickly accesed again, thus the amortized time complexity of any operation is still O(log n)."),(0,r.kt)("h4",{id:"what-are-they-used-for-8"},"What are they used for?"),(0,r.kt)("p",null,"An AVL seems to be the best data structure in Database Theory.\nRBTs are used to organize pieces of comparable data, such as text fragments or numbers. In the version 8 of Java, HashMaps are implemented using RBTs. Data structures in computational geometry and functional programming are also built with RBTs.\nSplay trees are used for caches, memory allocators, garbage collectors, data compression, ropes (replacement of string used for long text strings), in Windows NT (in the virtual memory, networking, and file system code)."),(0,r.kt)("h4",{id:"properties-8"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the amortized time complexity of ANY operation in ANY self-balancing BST is O(log n);"),(0,r.kt)("li",{parentName:"ul"},"the maximum height of an AVL in worst case is 1.44 ",(0,r.kt)("em",{parentName:"li"}," log2n (Why? "),"hint: think about the case of an AVL with all levels full, except the last one that has only a single element);"),(0,r.kt)("li",{parentName:"ul"},"AVLs are the fastest in practice for searching elements, but the rotation of subtrees for self-balancing is costly;"),(0,r.kt)("li",{parentName:"ul"},"meanwhile, RBTs provide faster insertions and deletions because there are no rotations;"),(0,r.kt)("li",{parentName:"ul"},"Splay trees don\u2019t need to store any bookkeeping data.")),(0,r.kt)("h4",{id:"useful-links-8"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.geeksforgeeks.org/avl-tree-set-1-insertion/"},"GeeksforGeeks: AVL Trees")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/"},"GeeksforGeeks: Red-Black Trees")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.geeksforgeeks.org/splay-tree-set-1-insert/"},"GeeksforGeeks: Splay Trees"))),(0,r.kt)("h3",{id:"10heaps"},"10.Heaps"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--llGwRQsW--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/ucdjtg4igymdfsc5vzuk.jpg"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--llGwRQsW--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/ucdjtg4igymdfsc5vzuk.jpg",alt:"Heaps"}))),(0,r.kt)("p",null,"A min-heap is a binary tree where each node has the property that its value is bigger or equal to its parent\u2019s value: ",(0,r.kt)("em",{parentName:"p"},"val[par","[x]","] <= val","[x]"),", with x a node of the heap, where ",(0,r.kt)("em",{parentName:"p"},"val","[x]")," is its value and ",(0,r.kt)("em",{parentName:"p"},"par","[x]")," its parent.\nThere is also a max-heap which implements the opposite relation.\nA binary heap is a complete binary tree (all its levels are filled, except maybe for the last level)."),(0,r.kt)("h4",{id:"what-are-they-used-for-9"},"What are they used for?"),(0,r.kt)("p",null,"As we\u2019ve discussed about it a few days earlier, priority queues can be efficiently implemented using a binary heap because it supports insert(), delete(), extractMax() and decreaseKey() operations in O(log n) time. That way, heaps are also essential in graph algorithms (because of the priority queue).\nAnytime that you would need quick access to the maximum/minimum item, a heap is the best option.\nHeaps are also the base of the heapsort algorithm."),(0,r.kt)("h4",{id:"properties-9"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"it is always balanced: anytime we delete/insert an element in the structure, we just have to \u201csift\u201d/\u201dpercolate\u201d it until it is in the right position;"),(0,r.kt)("li",{parentName:"ul"},"the parent of a node ",(0,r.kt)("em",{parentName:"li"},"k > 1")," is ",(0,r.kt)("em",{parentName:"li"},"[k/2]")," (where ","[x]"," is the integer part of x) and its children are ",(0,r.kt)("em",{parentName:"li"},"2","*","k")," and ",(0,r.kt)("em",{parentName:"li"},"2","*","k+1"),";"),(0,r.kt)("li",{parentName:"ul"},"an alternative of a priority queue are set, ordered_map (in C++) or any other ordered structure that can easily permit the access to the minimum/maximum element;"),(0,r.kt)("li",{parentName:"ul"},"the root is prioritized, so the time complexity of its access is O(1), insertion/deletion are done in O(log n); creating a heap is done in O(n); heapsort in O(n*log n).")),(0,r.kt)("h4",{id:"useful-links-9"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.geeksforgeeks.org/heap-data-structure/"},"GeeksforGeeks: Heaps"))),(0,r.kt)("h3",{id:"11tries"},"11.Tries"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--9ff3NhOI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/048ragftsnonpc6egurh.jpg"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--9ff3NhOI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/048ragftsnonpc6egurh.jpg",alt:"Tries"}))),(0,r.kt)("p",null,"A trie is an efficient information reTRIEval data structure. Also known as a prefix tree, it is a search tree which allows insertion and searching in O(L) time complexity, where L is the length of the key.\nIf we store keys in a well balanced BST, it will need time proportional to L * log n, where n is the number of keys in the tree. That way, a trie is a way faster data structure (with O(L)) compared to a BST, but the penalty is on the trie storage requirements."),(0,r.kt)("h4",{id:"what-are-they-used-for-10"},"What are they used for?"),(0,r.kt)("p",null,"A trie is mostly used for storing strings and their values. One of its coolest application is the typing autocomplete & autosuggestions in the Google search bar. A trie is the best choice because it is the fastest option: a faster search is more valuable than the storage saved if we didn\u2019t use a trie.\nOrtographical autocorrection of typed words is also done using a trie, by looking for the word in the dictionary or maybe for other instances of it in the same text."),(0,r.kt)("h4",{id:"properties-10"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"it has a key-value association; the key is usually a word or a prefix of it, but it can be any ordered list;"),(0,r.kt)("li",{parentName:"ul"},"the root has an empty string as a key;"),(0,r.kt)("li",{parentName:"ul"},"the length difference between a node\u2019s value and its children\u2019s values is 1; that way, the root\u2019s children will store a value of length 1; as a conclusion, we can say that a node x from a level k has a value of length k;"),(0,r.kt)("li",{parentName:"ul"},"as we\u2019ve said, the time complexity of insert/search operations is O(L), where L is the length of the key, which is way faster than a BST\u2019s O(log n), but comparable to a hashtable;"),(0,r.kt)("li",{parentName:"ul"},"space complexity is actually a disadvantage: O(ALPHABET_SIZE",(0,r.kt)("em",{parentName:"li"},"L"),"n).")),(0,r.kt)("h4",{id:"useful-links-10"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://medium.com/basecs/trying-to-understand-tries-3ec6bede0014"},"Medium: Trying to understand tries")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.geeksforgeeks.org/trie-insert-and-search/"},"GeeksforGeeks: Tries"))),(0,r.kt)("h3",{id:"12-segment-trees"},"12. Segment Trees"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--LWkZTMYp--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/776hxaevarl4fx2ms3hb.jpg"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--LWkZTMYp--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/776hxaevarl4fx2ms3hb.jpg",alt:"Segment Trees"}))),(0,r.kt)("p",null,"A segment tree is a full binary tree that allows answering to queries efficiently, while still easily modifying its elements.\nEach element on index i in the given array represents a leaf labeled with the ",(0,r.kt)("em",{parentName:"p"},"[i, i]")," interval. A node having its children labeled ",(0,r.kt)("em",{parentName:"p"},"[x, y]"),", respectively ",(0,r.kt)("em",{parentName:"p"},"[y, z]"),", will have the ",(0,r.kt)("em",{parentName:"p"},"[x, z]")," interval as a label. Therefore, given n elements (0-indexed), the root of the segment tree will be labeled with ",(0,r.kt)("em",{parentName:"p"},"[0, n-1]"),"."),(0,r.kt)("h4",{id:"what-are-they-used-for-11"},"What are they used for?"),(0,r.kt)("p",null,"They are extremely useful in tasks that can be solved using Divide & Conquer (first Algorithms concept that we are going to discuss) and also might require updates on their elements. That way, while updating the element, any interval containing it is also modified, thus the complexity is logarithmic. For instance, the sum/maximum/minimum of n given elements are the most common applications of segment trees. Binary search can also use a segment tree if element updates are ocurring."),(0,r.kt)("h4",{id:"properties-11"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"being a binary tree, a node x will have ",(0,r.kt)("em",{parentName:"li"},"2","*","x")," and ",(0,r.kt)("em",{parentName:"li"},"2","*","x+1")," as children and ",(0,r.kt)("em",{parentName:"li"},"[x/2]")," as a parent, where ",(0,r.kt)("em",{parentName:"li"},"[x]")," is the integer part of x;"),(0,r.kt)("li",{parentName:"ul"},"one efficient method of updating a whole range in a segment tree is called \u201cLazy Propagation\u201d and it is also done in O(log n) (see links below for the implementation of the operations);"),(0,r.kt)("li",{parentName:"ul"},"they can be k-dimensional : for example, having q queries of finding the sum of given submatrices of one matrix, we can use a 2-dimensional segment tree;"),(0,r.kt)("li",{parentName:"ul"},"updating elements/ranges require O(log n) time; answering to a query is constant (O(1));"),(0,r.kt)("li",{parentName:"ul"},"the space complexity is linear, which is a BIG advantage: O(4*n).")),(0,r.kt)("h4",{id:"useful-links-11"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://cp-algorithms.com/data_structures/segment_tree.html#toc-tgt-10"},"CP Agorithms: Segment Trees. Lazy propagation")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/"},"GeeksforGeeks: Segment Trees")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://codeforces.com/blog/entry/22616"},"Codeforces Problem Set"))),(0,r.kt)("h3",{id:"13-fenwick-trees"},"13. Fenwick Trees"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--5S1FO4bn--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/lhdmxcdawt7vhfwgtuh1.jpg"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--5S1FO4bn--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/lhdmxcdawt7vhfwgtuh1.jpg",alt:"BIT"}))),(0,r.kt)("p",null,"A fenwick tree, also known as a binary indexed tree (BIT), is a data structure that is also used for efficient updates and queries. Compared to Segment Trees, BITs require less space and are easier to implement."),(0,r.kt)("h4",{id:"what-are-they-used-for-12"},"What are they used for?"),(0,r.kt)("p",null,"BITs are used to calculate prefix sums \u2014 the prefix sum of the element on the ith position is the sum of the elements from the first position to the ith. They are represented using an array, where every index is represented in the binary system. For instance, an index 10 is equivalent to an index 2 in the decimal system."),(0,r.kt)("h4",{id:"properties-12"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the construction of the tree is the most interesting part: firstly, the array should be 1-indexed; to find the parent of the node x, you should convert its index x to the binary system and flip the right-most significant bit; ex. the parent of node 6 is 4; ",(0,r.kt)("em",{parentName:"li"},"6 = 1","*","2\xb2+1","*","2\xb9+0","*",'2\u2070 => 1"1"0 (flip)=> 100 = 1',"*","2\xb2+0","*","2\xb9+0","*","2\u2070 = 4"),";"),(0,r.kt)("li",{parentName:"ul"},"finally, ANDing elements, each node should contain an interval that can be added to the prefix sum (more about the construction and implementation in the links below);"),(0,r.kt)("li",{parentName:"ul"},"the time complexity is still O(log n) for updates and O(1) on queries, but the space complexity is even a greater advantage: O(n), compared to segment tree\u2019s O(4*n).")),(0,r.kt)("h4",{id:"useful-links-12"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=CWDQJGaN1gY&feature=youtu.be"},"Tushar Roy: BIT")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/amp/"},"GeeksforGeeks: BIT")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://cp-algorithms.com/data_structures/fenwick.html"},"CP Algorithms: BIT"))),(0,r.kt)("h3",{id:"14-disjoint-set-union"},"14. Disjoint Set Union"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--U65BRPq4--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/qrthz7m51000icho4ypw.jpg"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--U65BRPq4--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/qrthz7m51000icho4ypw.jpg",alt:"DSU"}))),(0,r.kt)("p",null,"We are given n elements, each of them representing a separate set. Disjoint Set Union (DSU) permits us to do two operations:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"UNION \u2014 combine any two sets (or unify the sets of two different elements if they\u2019re not from the same set);"),(0,r.kt)("li",{parentName:"ol"},"FIND \u2014 find the set an element comes from.")),(0,r.kt)("h4",{id:"what-are-they-used-for-13"},"What are they used for?"),(0,r.kt)("p",null,"DSUs are very important in graph theory. You could check if two vertices come from the same connected component or maybe even unify two connected components.\nLet\u2019s take the example of cities and towns. Since neighbour cities with demographical and economical growth are expanding, they can easily create a metropolis. Therefore, two cities are combined and their residents live in the same metropolis. We can also check what city a person lives in, by calling the FIND function."),(0,r.kt)("h4",{id:"properties-13"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"they are represented using trees; once two sets are combined, one of the two roots becomes the main root and the parent of the other root is one of the other tree\u2019s leaves;"),(0,r.kt)("li",{parentName:"ul"},"one kind of practical optimization is the compression of trees by their height; that way, the union is made by the biggest tree to easily update both of their data (see implementation below);"),(0,r.kt)("li",{parentName:"ul"},"all operations are done in O(1) time.")),(0,r.kt)("h4",{id:"useful-links-13"},"Useful links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.geeksforgeeks.org/union-find/"},"GeeksforGeeks: DSU")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://cp-algorithms.com/data_structures/disjoint_set_union.html"},"CP Algorithms: DSU")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://codeforces.com/problemset?tags=dsu"},"Codeforces Problem Set"))),(0,r.kt)("h3",{id:"15-minimum-spanning-trees"},"15. Minimum Spanning Trees"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://res.cloudinary.com/practicaldev/image/fetch/s--H3xDKVeD--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/509vak2sx9ewmrq0dd49.jpg"},(0,r.kt)("img",{parentName:"a",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--H3xDKVeD--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/509vak2sx9ewmrq0dd49.jpg",alt:"MST"}))),(0,r.kt)("p",null,"Given a connected and undirected graph, a spanning tree of that graph is a subgraph that is a tree and connects all the nodes together. A single graph can have many different spanning trees. A minimum spanning tree (MST) for a weighted, connected and undirected graph is a spanning tree with weight (cost) less than or equal to the weight of every other spanning tree. The weight of a spanning tree is the sum of weights given to each edge of the spanning tree."),(0,r.kt)("h4",{id:"what-are-they-used-for-14"},"What are they used for?"),(0,r.kt)("p",null,"The MST problem is an optimization problem, a minimum cost problem. Having a network of routes, we can consider that one of the factors that influence the establishment of a national route between n cities is the minimum distance between two adjacent cities.\nThat way, the national route is represented by the MST of the roads network\u2019s graph."),(0,r.kt)("h4",{id:"properties-14"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"being a tree, an MST of a graph with n vertices has ",(0,r.kt)("em",{parentName:"li"},"n-1")," edges; it can be solved using:"),(0,r.kt)("li",{parentName:"ul"},"*"," Prim\u2019s Algorithm \u2014 best option for dense graphs (graphs with n nodes and the number of edges is close to ",(0,r.kt)("em",{parentName:"li"},"n(n-1)/2"),");"),(0,r.kt)("li",{parentName:"ul"},"*"," Kruskal\u2019s Algorithm \u2014 mostly used; it is a Greedy algorithm based on Disjoint Set Union (we are going to discuss about it too);"),(0,r.kt)("li",{parentName:"ul"},"the time complexity of building it is O(n log n) or O(n log m) for Kruskal (it depends on the graph) and O(n\xb2) for Prim.")),(0,r.kt)("h4",{id:"useful-links-14"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://cp-algorithms.com/graph/mst_kruskal.html"},"CP Algorithms: MST")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=5INWifzqStU&feature=youtu.be"},"MST Tutorial"))),(0,r.kt)("h2",{id:"ii-algorithms-1"},"II. Algorithms"),(0,r.kt)("h3",{id:"1-divide-and-conquer"},"1. Divide and Conquer"),(0,r.kt)("p",null,"Divide and Conquer (DAC) is not a specific algorithm itself, but an important category of algorithms that needs to be understood before diving into other topics. It is used to solve problems that can be divided into subproblems that are similar to the original problem, but smaller in size. DAC then recursively solves them and finally merges the results to find the solution of the problem.\nIt has three stages:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Divide \u2014 the problems into subproblems;"),(0,r.kt)("li",{parentName:"ul"},"Conquer \u2014 the subproblems by using recursion;"),(0,r.kt)("li",{parentName:"ul"},"Merge \u2014 the subproblems\u2019 results into the final solution.")),(0,r.kt)("h4",{id:"what-is-it-used-for"},"What is it used for?"),(0,r.kt)("p",null,"One practical application of DAC is parallel programming using multiple processors, so the subproblems are executed on different machines.\nDAC is the base of many algorithms such as Quick Sort, Merge Sort, Binary Search or fast multiplication algorithms."),(0,r.kt)("h4",{id:"properties-15"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"each DAC problem can be written as a recurrence relation; so, it is essential to find the basic case that stops the recursion;"),(0,r.kt)("li",{parentName:"ul"},"its complexity is ",(0,r.kt)("em",{parentName:"li"},"T(n)=D(n)+C(n)+M(n)"),", meaning that every stage has a different complexity depending on the problem.")),(0,r.kt)("h4",{id:"useful-links-15"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[Divide and Conquer Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Divide"},"https://github.com/iuliagroza/Algorithms/blob/master/Divide")," and Conquer)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.geeksforgeeks.org/divide-and-conquer-algorithm-introduction/"},"GeeksforGeeks: DAC")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://brilliant.org/wiki/divide-and-conquer/"},"Brilliant: DAC"))),(0,r.kt)("h3",{id:"2-sorting-algorithms"},"2. Sorting Algorithms"),(0,r.kt)("p",null,"A sorting algorithm is used to rearrange given elements (from an array or list) according to a comparison operator on the elements. When we refer to a sorted array, we usually think of ascending order (the comparison operator is \u2018<\u2019). There are various types of sorting, with different time and space complexities. Some of them are comparison based, others not. Here are the most popular/efficient sorting methods:"),(0,r.kt)("h4",{id:"bubble-sort"},"Bubble Sort"),(0,r.kt)("p",null,"Bubble Sort is one of the simplest sorting algorithms. It is based on a repeated swap between adjacent elements if they are in wrong order. It is stable, its time complexity is O(n\xb2) and it needs O(1) auxiliary space."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://youtu.be/nmhjrI-aW5o"},"Bubble Sort Visualization"))),(0,r.kt)("h4",{id:"counting-sort"},"Counting Sort"),(0,r.kt)("p",null,"Counting Sort is not a comparison based sorting. It is basically using the frequency of each element (a kind of hashing), determining the minimum and maximum value and then iterating between them to place each element based on its frequency. It\u2019s done in O(n) and the space is proportional to the range of data. It is efficient if the range of input is not significantly greater than the number of elements."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://youtu.be/7zuGmKfUt7s"},"Counting Sort Visualization"))),(0,r.kt)("h4",{id:"quick-sort"},"Quick Sort"),(0,r.kt)("p",null,"Quick Sort is an application of Divide and Conquer. It is based on choosing an element as a pivot (first, last or median) and then swapping elements in order to place the pivot between all the elements smaller than it and all the elements bigger than it. It has no additional space and O(n*log n) time complexity \u2014 the best complexity for comparison based methods.\nHere is a demo with choosing the pivot as the last element:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=PgBzjlCcFvc&feature=emb_title"},"Quick Sort Visualization"))),(0,r.kt)("h4",{id:"merge-sort"},"Merge Sort"),(0,r.kt)("p",null,"Merge Sort is also a Divide & Conquer application. It divides the array in two halves, sorts each half and then merges them. Its time complexity is also O(n*log n), so it is also super fast like Quick Sort, but it unfortunately needs O(n) additional space to store two subarrays at the same time and, finally, merge them."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://youtu.be/JSceecw-Eyw"},"Merge Sort Visualization"))),(0,r.kt)("h4",{id:"radix-sort"},"Radix Sort"),(0,r.kt)("p",null,"Radix Sort uses Counting Sort as a subroutine, so it is not a comparison based algorithm. How do we know CS is not enough? Suppose we have to sort elements in ",(0,r.kt)("em",{parentName:"p"},"[1, n\xb2]"),". Using CS, it would take us O(n\xb2). We need a linear algorithm \u2014 O(n+k), where elements are in range ",(0,r.kt)("em",{parentName:"p"},"[1, k]"),". It sorts the elements digit by digit starting with the least significant one (units), to the most (tens, hundreds etc.). Additional space (from CS): O(n)."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://youtu.be//nu4gDuFabIM"},"Radix Sort Visualization"))),(0,r.kt)("h4",{id:"useful-links-16"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[Bubble Sort Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Bubble"},"https://github.com/iuliagroza/Algorithms/blob/master/Bubble")," Sort)"),(0,r.kt)("li",{parentName:"ul"},"[Counting Sort Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Counting"},"https://github.com/iuliagroza/Algorithms/blob/master/Counting")," Sort)"),(0,r.kt)("li",{parentName:"ul"},"[Quick Sort Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Quick"},"https://github.com/iuliagroza/Algorithms/blob/master/Quick")," Sort)"),(0,r.kt)("li",{parentName:"ul"},"[Merge Sort Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Merge"},"https://github.com/iuliagroza/Algorithms/blob/master/Merge")," Sort)"),(0,r.kt)("li",{parentName:"ul"},"[Radix Sort Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Radix"},"https://github.com/iuliagroza/Algorithms/blob/master/Radix")," Sort)")),(0,r.kt)("h3",{id:"3-searching-algorithms"},"3. Searching Algorithms"),(0,r.kt)("p",null,"Searching Algorithms are designed to check for the existence of an element in a data structure and even return it. There are a couple of searching methods, but here are the most popular two:"),(0,r.kt)("h4",{id:"linear-search"},"Linear Search"),(0,r.kt)("p",null,"This algorithm\u2019s approach is very simple: you start searching for your value from the first index of the data structure. You compare them one by one until your value and your current element are equal. If that specific value is not in the DS, return -1.\nTime Complexity: O(n)"),(0,r.kt)("h4",{id:"binary-search"},"Binary Search"),(0,r.kt)("p",null,"BS is one efficient search algorithm based on Divide and Conquer. Unfortunately, it only works only on sorted data structures. Being a DAC method, you continuously divide the DS in two halves and compare your in-search value with the middle element\u2019s value. If they are equal, the search is finished. Either way, if your value is bigger/smaller than it, the search should continue on the right/left half.\nTime Complexity: O(log n)"),(0,r.kt)("h4",{id:"useful-links-17"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[Linear Search Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Linear"},"https://github.com/iuliagroza/Algorithms/blob/master/Linear")," Search)"),(0,r.kt)("li",{parentName:"ul"},"[Binary Search Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Binary"},"https://github.com/iuliagroza/Algorithms/blob/master/Binary")," Search)")),(0,r.kt)("h3",{id:"4-sieve-of-eratosthenes"},"4. Sieve of Eratosthenes"),(0,r.kt)("p",null,"Given an integer number n, print all the prime numbers smaller or equal to n.\nSieve of Eratosthenes is one of the most efficient algorithms that solves this problem and it perfectly works for n smaller than ",(0,r.kt)("em",{parentName:"p"},"10.000.000"),".\nThe method uses a frequency list/map that marks the primality of every number in the range ",(0,r.kt)("em",{parentName:"p"},"[0, n]"),": ",(0,r.kt)("em",{parentName:"p"},"ok","[x]","=0")," if x is prime, ",(0,r.kt)("em",{parentName:"p"},"ok","[x]","=1")," otherwise.\nWe begin choosing every prime number from our list and marking its multiples from the list with 1 \u2014 that way, we choose the unmarked (0) numbers. Finally, we can easily answer in O(1) to as many queries as we want.\nThe classical algorithm is essential in many applications, but there are a few optimizations we can make. Firstly, we can easily notice 2 is the only even prime number, so we can check for its multiples separately and then iterate in the range in order to find prime numbers from two to two. Secondly, it is obvious that for a number x, we had previously checked 2x, 3x, 4x etc. when we were iterating through 2, 3 etc. That way, our multiples check for-loop can start from x\xb2 every time. Finally, even half of these multiples are even and we are also iterating through odd prime numbers, so we can easily iterate just from 2",(0,r.kt)("em",{parentName:"p"},"x to 2"),"x in the multiples check loop.\nSpace complexity: O(n)\nTime complexity: O(n",(0,r.kt)("em",{parentName:"p"},"log(log n)) for the classical algorithm, O(n) for the optimized one.\nWhy O(n"),"log(log n))?\n",(0,r.kt)("a",{parentName:"p",href:"https://geeksforgeeks.org/how-is-the-time-complexity-of-sieve-of-eratosthenes-is-nloglogn/amp/"},"The answer")),(0,r.kt)("h4",{id:"useful-links-18"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[Sieve of Eratosthenes Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Sieve"},"https://github.com/iuliagroza/Algorithms/blob/master/Sieve")," of Eratosthenes)")),(0,r.kt)("h3",{id:"5-knuth-morris-pratt-algorithm"},"5. Knuth-Morris-Pratt Algorithm"),(0,r.kt)("p",null,"Given a text of length n and a pattern of length m, find all the occurrences of the pattern in the text.\nKnuth-Morris-Pratt Algorithm (KMP) is an efficient way to solve the pattern matching problem.\nThe naive solution is based on using a \u201csliding window\u201d, where we compare character to character every time we set a new beginning index, starting from index 0 of the text to index n-m. That way, time complexity is O(m",(0,r.kt)("em",{parentName:"p"},"(n-m+1))~O(n"),"m).\nKMP is an optimization to the naive solution: it is done in O(n) and it is working the best when the pattern has many repeating subpatterns. Thereby, it is also using a sliding window, but instead of comparing all the characters to the substring\u2019s, it is constantly looking for the longest suffix of the current subpattern which is also its prefix. In other words, anytime we detect a mismatch after some matches, we already know some of the characters in the text of the next window. Therefore, it is useless to match them again, so we restart the matching with the same character in the text with a character after that prefix. How do we know how many characters we should skip? Well, we should build a pre-process array that tells us how many characters should be skipped."),(0,r.kt)("h4",{id:"useful-links-19"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=GTJr8OvyEVQ"},"Tushar Roy: KMP Tutorial")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/KMP"},"KMP Implementation"))),(0,r.kt)("h3",{id:"6-greedy"},"6. Greedy"),(0,r.kt)("p",null,"The Greedy method is mostly used for problems that require optimization and the local optimal solution leads to the global optimal solution.\nThat being said, when using Greedy, the optimal solution at each step leads to the overall optimal solution. However, in most cases, the decision we make at one step affects the list of decisions for the next step. In this case, the algorithm must be mathematically demonstrated. Greedy also produces great solutions on some mathematical problems, but not on all (it is possible that the most optimal solution is not guaranteed)!"),(0,r.kt)("p",null,"A Greedy algorithm generally has five components:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a candidate set \u2014 from which a solution is created;"),(0,r.kt)("li",{parentName:"ul"},"a selection function \u2014 chooses the best candidate;"),(0,r.kt)("li",{parentName:"ul"},"a feasibility function \u2014 can determine if a candidate is able to contribute to the solution;"),(0,r.kt)("li",{parentName:"ul"},"an objective function \u2014 assigns the candidate to the (partial) solution;"),(0,r.kt)("li",{parentName:"ul"},"a solution function \u2014 builts the solution from the partial solutions.")),(0,r.kt)("h4",{id:"fractional-knapsack-problem"},"Fractional Knapsack Problem"),(0,r.kt)("p",null,"Given weights and values of n items, we need to put these items in a knapsack of capacity W to get the maximum total value in the knapsack (taking pieces of items is allowed: the value of a piece is proportional with its weight).\nThe basic idea of the greedy approach is to sort all the items on basis of their value/weight ratio. Then, we can add as many whole items as we can. In the moment we find an item heavier (w2) than our available weight left in the knapsack (w1), we will fractionate it: take only ",(0,r.kt)("em",{parentName:"p"},"w2-w1")," of it to maximize our profit. It is guaranteed this greedy solution is correct."),(0,r.kt)("h4",{id:"useful-links-20"},"Useful links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[Maximum number of non-overlapping intervals Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Greedy"},"https://github.com/iuliagroza/Algorithms/blob/master/Greedy"),". Maximum number of non-overlapping intervals on an axis)"),(0,r.kt)("li",{parentName:"ul"},"[Fractional Knapsack Problem Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Fractional"},"https://github.com/iuliagroza/Algorithms/blob/master/Fractional")," Knapsack Problem)")),(0,r.kt)("h3",{id:"7-dynamic-programming"},"7. Dynamic Programming"),(0,r.kt)("p",null,"Dynamic Programming (DP) is a similar approach to Divide & Conquer. It also breaks the problem into similar subproblems, but they are actually overlapping and codependent \u2014 they\u2019re not solved independently.\nEach subproblem\u2019s result can be used anytime later and it is built using memoization (precalculation). DP is mostly used for (time & space) optimization and it is based on finding a recurrence.\nDP applications include Fibonacci number series, Tower of Hanoi, Roy-Floyd-Warshall, Dijkstra etc. Below we are going to discuss about a DP solution of the 0\u20131 Knapsack Problem."),(0,r.kt)("h4",{id:"01-knapsack-problem"},"0\u20131 Knapsack Problem"),(0,r.kt)("p",null,"Given weights and values of n items,we need to put these items in a knapsack of capacity W to get the maximum total value in the knapsack (fractioning items just as in the Greedy solution is not allowed).\nThe 0\u20131 property is given by the fact that we should either pick the whole item or not choose it at all.\nWe build a DP structure as a matrix ",(0,r.kt)("em",{parentName:"p"},"dp","[i][cw]")," storing the maximum profit that we can obtain by choosing i objects whose total weight is cw. It is easy to notice that we should firstly initialize ",(0,r.kt)("em",{parentName:"p"},"dp","[1]","w","[i]","]")," with ",(0,r.kt)("em",{parentName:"p"},"v","[i]"),", where ",(0,r.kt)("em",{parentName:"p"},"w","[i]")," is the weight of the ith object and ",(0,r.kt)("em",{parentName:"p"},"v","[i]")," its value.\nThe recurrence is the following: ",(0,r.kt)("em",{parentName:"p"},"dp","[i][cw]"," = max(dp","[i-1][cw]",", dp","[i-1]","cw-w","[i]","]+v","[i]",")"),". Let\u2019s analyze it a little bit.\n",(0,r.kt)("em",{parentName:"p"},"dp","[i-1][cw]")," depicts the case in which we do not add the current item in the knapsack. ",(0,r.kt)("em",{parentName:"p"},"dp","[i-1]","cw-w","[i]","]+v","[i]")," is the case in which we add the item. That being said, ",(0,r.kt)("em",{parentName:"p"},"dp","[i-1]","cw-w","[i]","]")," is the maximum profit of taking i-1 elements: so their weight is the current weight without our item\u2019s weight. Finally, we add our item\u2019s value to it.\nThe answer is stored into ",(0,r.kt)("em",{parentName:"p"},"dp","[n][W]"),". An optimization is made with a simple observation: in the recurrence, the current line (row) is influenced only by the previous line. Therefore, storing the DP structure into a matrix is unnecessary, so we should choose an array for a better space complexity: O(n). Time complexity: O(n*W)."),(0,r.kt)("h4",{id:"useful-links-21"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0\u20131 Knapsack Problem Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Dynamic"},"https://github.com/iuliagroza/Algorithms/blob/master/Dynamic")," Programming. 0-1 Knapsack Problem)")),(0,r.kt)("h3",{id:"8-longest-common-subsequence"},"8. Longest Common Subsequence"),(0,r.kt)("p",null,"Given two sequences, find the length of the longest subsequence present in both of them. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous. For example, \u201cbcd\u201d, \u201cabdg\u201d, \u201cc\u201d are subsequences of \u201cabcdefg\u201d.\nHere is another application of dynamic programming. The LCS algorithm uses DP in order to solve the problem from above.\nThe actual subproblem is going to find the longest common subsequence that starts from index i in the sequence A, respectively from index j in the sequence B.\nNext, we will build the DP structure ",(0,r.kt)("em",{parentName:"p"},"lcs","[ ][ ]")," (matrix), where ",(0,r.kt)("em",{parentName:"p"},"lcs","[i][j]")," is the maximum length of a common subsequence that starts from index i in A, respectively index j in B. We are going to build it in a top-down manner. The solution is, obviously, stored in ",(0,r.kt)("em",{parentName:"p"},"lcs","[n][m]"),", where n is the length of A and m the length of B.\nThe recurrence relation is pretty simple and intuitive. For simplicity, we are going to consider that both sequences are 1-indexed. Firstly, we are going to initialize ",(0,r.kt)("em",{parentName:"p"},"lcs","[i][0]"),", ",(0,r.kt)("em",{parentName:"p"},"1<=i<=n"),", and ",(0,r.kt)("em",{parentName:"p"},"lcs","[0][j]"),", ",(0,r.kt)("em",{parentName:"p"},"1<=j<=m"),", with 0, as basic cases (there is no subsequence that starts from 0). Then, we will take into consideration two main cases: if ",(0,r.kt)("em",{parentName:"p"},"A","[i]")," is equal to ",(0,r.kt)("em",{parentName:"p"},"B","[j]"),", then ",(0,r.kt)("em",{parentName:"p"},"lcs","[i][j]"," = lcs","[i-1][j-1]","+1")," (one more identic character than the previous LCS). Otherwise, it will be the maximum between ",(0,r.kt)("em",{parentName:"p"},"lcs","[i-1][j]")," (if ",(0,r.kt)("em",{parentName:"p"},"A","[i]")," is not taken into consideration) and ",(0,r.kt)("em",{parentName:"p"},"lcs","[i][j-1]")," (if ",(0,r.kt)("em",{parentName:"p"},"B","[j]")," is not taken into consideration).\nTime Complexity: O(n",(0,r.kt)("em",{parentName:"p"},"m)\nAdditional Space: O(n"),"m)"),(0,r.kt)("h4",{id:"useful-links-22"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[LCS Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Longest"},"https://github.com/iuliagroza/Algorithms/blob/master/Longest")," Common Subsequence)")),(0,r.kt)("h3",{id:"9-longest-increasing-subsequence"},"9. Longest Increasing Subsequence"),(0,r.kt)("p",null,"Given a sequence A of n elements, find the length of the longest subsequence such that all of its elements are sorted in increasing order. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous. For example \u201cbcd\u201d, \u201cabdg\u201d, \u201cc\u201d are subsequences of \u201cabcdefg\u201d.\nLIS is another classic problem that can be solved using Dynamic Programming.\nFinding the maximum length of an increasing subsequence is done using an array ",(0,r.kt)("em",{parentName:"p"},"l","[ ]")," as a DP structure, where ",(0,r.kt)("em",{parentName:"p"},"l","[i]")," is the maximum length of an increasing subsequence that contains ",(0,r.kt)("em",{parentName:"p"},"A","[i]"),", having its elements from the ",(0,r.kt)("em",{parentName:"p"},"[A","[i]",", \u2026, A","[n]","]")," subsequence. ",(0,r.kt)("em",{parentName:"p"},"l","[i]")," is 1, if all the elements after ",(0,r.kt)("em",{parentName:"p"},"A","[i]")," are smaller than it. Otherwise, it\u2019s 1+ maximum between all the elements after A","[i]"," which are bigger than it. Obviously, ",(0,r.kt)("em",{parentName:"p"},"l","[n]","=1"),", where n is the length of A. The implementation is done in a bottom-up manner (starting from the end).\nOne optimization problem appears in searching the maximum between all the elements after the current element. The best we can do is to binary search the maximum element.\nTo also find a subsequence of the now known maximum length, we just have to use an additional array ",(0,r.kt)("em",{parentName:"p"},"ind","[ ]"),", that stores the index of each maximal value.\nTime Complexity: O(n*log n)\nAdditional Space: O(n)"),(0,r.kt)("h4",{id:"useful-links-23"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[LIS Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Longest"},"https://github.com/iuliagroza/Algorithms/blob/master/Longest")," Increasing Subsequence)")),(0,r.kt)("h3",{id:"10-convex-hull"},"10. Convex Hull"),(0,r.kt)("p",null,"Given a set of n points in the same plane, find the minimum area convex polygon that contains all of the given points (situated inside the polygon or on its sides). Such polygon is called a convex hull. The convex hull problem is a classic geometry that has many applications in real life. For instance, collision avoidance: if the convex hull of the car avoids collisions then so does the car. Computation of paths is done using convex representations of cars. Shape analysis is also done with the help of convex hulls. That way, image processing is easily done by matching models by their convex deficiency tree.\nThere are some algorithms used to find the convex hull, like Jarvis\u2019 Algorithm, Graham scanning etc. Today we are going to discuss about Graham scanning and some useful optimizations.\nGraham scanning sorts the points by their polar angle \u2014 the slope of the line determined by a certain point and the other chosen points. Then, a stack is used to store the convex hull at the current moment. When a point x is pushed into the stack, other points will be popped out of the stack until x and the line determined by the last two points form an angle smaller than 180\xb0. Finally, the last point introduced into the stack closes the polygon. This approach has a time complexity of O(n*log n) because of sorting. However, this method can produce precision errors when calculating the slope.\nOne improved solution that has the same time complexity, but smaller errors sorts the points by their coordinates (x, then y). Then we consider the line formed by the leftmost and rightmost points and the problem is divided in two subproblems. Finally, we find the convex hull on each side of the line. The convex hull of all the given points is the reunion of the two hulls."),(0,r.kt)("h4",{id:"useful-links-24"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[Convex Hull Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Convex"},"https://github.com/iuliagroza/Algorithms/blob/master/Convex")," Hull)")),(0,r.kt)("h3",{id:"11-graph-traversals"},"11. Graph Traversals"),(0,r.kt)("p",null,"The problem of traversing graphs reffers to visiting all the nodes in a particular order, usually computing other useful information along the way."),(0,r.kt)("h4",{id:"breadth-first-search"},"Breadth-First Search"),(0,r.kt)("p",null,"The Breadth-First Search (BFS) algorithm is one of the most common ways to determine if a graph is connected or not \u2014 or, in other words, to find the connected component of the source node of the BFS.\nBFS is also used to compute the shortest distance between the source node and all the other nodes. Another version of BFS is Lee\u2019s Algorithm used to compute the shortest path between two cells in a grid.\nThe algorithm starts by visiting the source node and then its neighbours that will be pushed into a queue. The first element from the queue is popped. We will visit all of its neighbours and push the ones that were not previously visited into the queue. The process is repeated until the queue is empty. When the queue becomes empty, it means that all the reachable vertices have been visited and the algorithm ends."),(0,r.kt)("h4",{id:"depth-first-search"},"Depth-First Search"),(0,r.kt)("p",null,"The Depth-First Search (DFS) algorithm is another common traversal method. It is actually the best option when it comes to checking the connectivity of a graph.\nFirst, we visit the root node and push it into a stack. While the stack is not empty, we examine the node at the top. if the node has unvisited neighbours, one of them is chosen and pushed in the stack. Otherwise, if all of its neighbours had been visited, we pop the node. When the stack becomes empty, the algorithm ends.\nAfter such traversal, a DFS tree is formed. The DFS tree has many applications; one of the most common is storing the \u201cstarting\u201d and \u201cending\u201d time of each node \u2014 the moment it enters the stack, respectively the moment it is popped out from it."),(0,r.kt)("h4",{id:"useful-links-25"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[BFS Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Breadth-First"},"https://github.com/iuliagroza/Algorithms/blob/master/Breadth-First")," Search)"),(0,r.kt)("li",{parentName:"ul"},"[DFS Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Depth-First"},"https://github.com/iuliagroza/Algorithms/blob/master/Depth-First")," Search)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://cs.usfca.edu/~galles/visualization/BFS.html"},"BFS Visualization")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://cs.usfca.edu/~galles/visualization/DFS.html"},"DFS Visualization"))),(0,r.kt)("h3",{id:"12-floyd-warshall-algorithm"},"12. Floyd-Warshall Algorithm"),(0,r.kt)("p",null,"The Floyd-Warshall / Roy-Floyd Algorithm solves the All Pairs Shortest Path problem: find the shortest distances between every pair of vertices in a given edge-weighted directed graph.\nFW is a Dynamic Programming application. The DP structure (matrix) ",(0,r.kt)("em",{parentName:"p"},"dist","[ ][ ]")," is initialized with the input graph matrix. Then we consider each vertex as an intermediate between other two nodes. The shortest paths are updated between every two pair of nodes, with any node k as an intermediate vertex. If k is an intermediate in the sortest path between i and j, ",(0,r.kt)("em",{parentName:"p"},"dist","[i][j]")," becomes the maximum between ",(0,r.kt)("em",{parentName:"p"},"dist","[i][k]","+dist","[k][j]")," and ",(0,r.kt)("em",{parentName:"p"},"dist","[i][j]"),".\nTime Complexity: O(n\xb3)\nSpace Complexity: O(n\xb2)"),(0,r.kt)("h4",{id:"useful-links-26"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Floyd-Warshall"},"FW Implementation"))),(0,r.kt)("h3",{id:"13-dijkstras-algorithm--bellman-ford-algorithm"},"13. Dijkstra\u2019s Algorithm & Bellman-Ford Algorithm"),(0,r.kt)("h4",{id:"dijkstras-algorithm"},"Dijkstra\u2019s Algorithm"),(0,r.kt)("p",null,"Given a graph and a source vertex in the graph, find the shortest paths from the source to all vertices in the given graph.\nDijkstra\u2019s Algorithm is used to find such paths in a weighted graph, where all weights are positive.\nDijkstra is a Greedy algorithm that uses a shortest path tree (SPT) with the source node as the root. A SPT is a self-balancing binary tree, but the algorithm can be implemented using a heap (or a priority queue). We\u2019re going to discuss about the heap solution, because its time complexity is O(|E|*log |V|). The idea is to work with an adjacency list representation of the graph. That way, the nodes will be traversed in O(|V|+|E|) time using BFS.\nAll vertices are traversed with BFS and those for which the shortest distance is not finalized yet are stored into a Min-Heap (priority queue).\nThe Min-Heap is created and every node is pushed into it along with their distance values. Then, the source becomes the root of the heap with a distance of 0. The other nodes will have infinite assigned as a distance. While the heap\u2019s not empty, we extract the minimum distance value node x. For every vertex y adjacent to x, we check if y is in the Min-Heap. In this case, if the distance value is bigger than the weight of (x, y) plus distance value of x, then we update the distance value of y."),(0,r.kt)("h4",{id:"bellman-ford-algorithm"},"Bellman-Ford Algorithm"),(0,r.kt)("p",null,"As we\u2019ve previously said, Dijkstra works only on positively weighted graphs. Bellman solves this problem. Given a weighted graph, we can check if it contains a negative cycle. If not, then we can also find the minimum distances from our source to the others (negative weights possible).\nBellman-Ford suites well for distributed systems, although its time complexity is O(|V|",(0,r.kt)("em",{parentName:"p"},"|E|).\nWe initialize a dist","[ ]"," just like in Dijkstra. For ","*","|V|-1")," times, for each ",(0,r.kt)("em",{parentName:"p"},"(x, y)")," edge, if ",(0,r.kt)("em",{parentName:"p"},"dist","[y]"," > dist","[x]"," + weight of (x, y)"),", then we update ",(0,r.kt)("em",{parentName:"p"},"dist","[y]")," with it.\nWe repeat the last step to possibly find a negative cycle. The idea is that the last step guarantees the minimum distance if there is no negative cycle. If there is any node that has a shorter distance in the current step than in the last one, then a negative cycle was detected."),(0,r.kt)("h4",{id:"useful-links-27"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Dijkstra"},"Dijkstra Implementation")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Bellman-Ford"},"BF Implementation"))),(0,r.kt)("h3",{id:"14-kruskals-algorithm"},"14. Kruskal\u2019s Algorithm"),(0,r.kt)("p",null,"We have previously discussed about what a Minimum Spanning Tree is.\nThere are two algorithms that find the MST of a graph: Prim (useful for dense graphs) and Kruskal (ideal for most graphs). Now we are going to discuss about Kruskal\u2019s Algorithm.\nKruskal has developed a greedy algorithm in order to find an MST. It\u2019s efficient on rare graphs, because its time complexity is O(|E|*log |V|).\nThe algorithm\u2019s approach is the following: we sort all the edges in increasing order of their weight. Then, the smallest edge is picked. If it does not form a cycle with the current MST, we include it. Otherwise, discard it. The last step is repeated until there are |V|-1 edges in the MST.\nThe inclusion of edges into the MST is done using Disjoint-Set-Union, also previously discussed."),(0,r.kt)("h4",{id:"useful-links-28"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Kruskal"},"Kruskal Implementation"))),(0,r.kt)("h3",{id:"15-topological-sorting"},"15. Topological Sorting"),(0,r.kt)("p",null,"A Directed Acyclic Graph (DAG) is simply a directed graph which contains no cycles.\nTopological sorting in a DAG is a linear ordering of vertices such that for every arch ",(0,r.kt)("em",{parentName:"p"},"(x, y)"),", node x comes before node y.\nObviously, the first vertex in a topological sorting is a vertex with a 0 in-degree (there are no arches directing to it).\nAnother special property is that a DAG doesn\u2019t have a unique topological sorting.\nThe BFS implementation follows this routine: a node with a 0 in-degree is found and pushed the first into the sorting. This vertex is removed from the graph. As the new graph is also a DAG, we can repeat the process."),(0,r.kt)("p",null,"At any point during DFS, a node can be in one of these three categories:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"nodes that we finished visiting (popped from the stack);"),(0,r.kt)("li",{parentName:"ul"},"nodes that are currently on the stack;"),(0,r.kt)("li",{parentName:"ul"},"nodes that are yet to be discovered.")),(0,r.kt)("p",null,"If during DFS in a DAG a node x has an outgoing edge to a node y, then y is either in the first or the third category. If y was on the stack, then ",(0,r.kt)("em",{parentName:"p"},"(x, y)")," would end a cycle, fact that contradicts the DAG definition.\nThis property actually tells us that a vertex is popped from the stack after all of its outgoing neighbours are popped. So to topological sort a graph, we need to keep track of a reversed order list of the popped vertices."),(0,r.kt)("h4",{id:"useful-links-29"},"Useful Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[Topological Sorting Implementation]","(",(0,r.kt)("a",{parentName:"li",href:"https://github.com/iuliagroza/Algorithms/blob/master/Topological"},"https://github.com/iuliagroza/Algorithms/blob/master/Topological")," Sorting)")),(0,r.kt)("p",null,"Woah, you have made it to the end of the article. Thanks for your attention! :) Have fun coding!"))}u.isMDXComponent=!0}}]);